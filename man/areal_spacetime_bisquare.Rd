% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/areal_spacetime_bisquare.R
\name{areal_spacetime_bisquare}
\alias{areal_spacetime_bisquare}
\title{Areal Space-Time Bisquare Basis}
\usage{
areal_spacetime_bisquare(dom, period, knots, w_s, w_t, control = NULL)
}
\arguments{
\item{dom}{An \code{sf} or \code{sfc} object with areas
\eqn{A_1, \ldots, A_n} to evaluate.}

\item{period}{A numeric vector of time periods \eqn{v_1, \ldots, v_m}
to evaluate for each area.}

\item{knots}{Spatio-temporal knots
\eqn{(\bm{c}_1,g_1), \ldots, (\bm{c}_r,g_r)}
for the basis. See "Details".}

\item{w_s}{Spatial radius for the basis.}

\item{w_t}{Temporal radius for the basis.}

\item{control}{A \code{list} of control arguments. See "Details".}
}
\value{
A sparse \eqn{n \times r} matrix whose \eqn{i}th row
is
\eqn{
\bm{s}_i^\top =
\Big(
\psi_1^{(m)}(A_i), \ldots, \psi_r^{(m)}(A_i)
\Big).
}
}
\description{
Space-Time bisquare basis on areal data.
}
\details{
Notes about arguments:
\itemize{
\item \code{knots} may be provided as either an \code{sf} or \code{sfc} object, or as a
  matrix of points.
\item If an \code{sf} or \code{sfc} object is provided for \code{knots}, \eqn{r}
  three-dimensional \code{POINT} entries are expected in \code{st_geometry(knots)}.
  Otherwise, \code{knots} will be interpreted as an \eqn{r \times 3} numeric matrix.
\item If \code{knots} is an \code{sf} or \code{sfc} object, it is checked
  to ensure the coordinate system matches \code{dom}.
}

For each area \eqn{A} in the given domain, and time period
\eqn{\bm{v} = (v_1, \ldots, v_m)} compute the basis
functions
\deqn{
\psi_j^{(m)}(A, \bm{v}) = \frac{1}{m} \sum_{k=1}^m \frac{1}{|A|} \int_A \psi_j(\bm{u},v_k) d\bm{u},
}
for \eqn{j = 1, \ldots, r}. Here, \eqn{\varphi_j{(\bm{u},v)}}
represent \link{spacetime_bisquare} basis functions defined at the point
level using \eqn{\bm{c}_j}, \eqn{g_j}, \eqn{w_s}, and \eqn{w_t}.

The basis requires an integration which may be computed using one
of two methods. The \code{mc} method uses a Monte Carlo approximation
\deqn{
\psi_j^{(m)}(A, \bm{v}) \approx \frac{1}{m} \sum_{k=1}^m 
\frac{1}{Q} \sum_{q=1}^Q \psi_j(\bm{u}_q, v_k),
}
based on a random sample of locations \eqn{\bm{u}_1, \ldots, \bm{u}_Q} from
a uniform distribution on area \eqn{A}. The \code{rect} method uses
a simple quadrature approximation
\deqn{
\psi_j^{(m)}(A, \bm{v}) \approx \frac{1}{m} \sum_{k=1}^m 
\frac{1}{|A|}  \sum_{a=1}^{n_x} \sum_{b=1}^{n_y} \psi_j(\bm{u}_{ab}, v_k)
I(\bm{u}_{ab} \in A) \Delta_x \Delta_y.
}
Here, the bounding box \code{st_bbox(A)} is divided evenly into a grid of
\eqn{n_x \times n_y} rectangles, each of size \eqn{\Delta_x \times \Delta_y}.
Each \eqn{\bm{u}_{ab} = (u_a, u_b)} is a point from the \eqn{(a,b)}th
rectangle, for \eqn{a = 1, \ldots, n_x} and \eqn{b = 1, \ldots, n_y}.

Due to the treatment of \eqn{A_i} and \eqn{\bm{c}_j} as objects in a
Euclidean space, this basis is more suitable for coordinates from a map
projection than coordinates based on a globe representation.

The \code{control} argument is a list which may provide any of the following:
\itemize{
\item \code{method} specifies computation method: \code{mc} or \code{rect}.
Default is \code{mc}.
\item \code{mc_reps} is number of repetitions to use for \code{mc}.
Default is 1000.
\item \code{nx} is number of x-axis points to use for \code{rect}
method. Default is 50.
\item \code{ny} is number of y-axis points to use for \code{rect}
method. Default is 50.
\item \code{report_period} is an integer; print a message with progress each
time this many areas are processed. Default is \code{Inf} so that message
is suppressed.
\item \code{verbose} is a logical; if \code{TRUE} print descriptive
messages about the computation. Default is \code{FALSE}.
\item \code{mc_sampling_factor} is a positive number; an oversampling factor
used to compute \code{blocksize} in the \link{rdomain} function. I.e.,
\code{blocksize = ceiling(mc_sampling_factor * mc_reps)}. Default
is 1.2.
}
}
\examples{
set.seed(1234)

# Create knot points
seq_x = seq(0, 1, length.out = 3)
seq_y = seq(0, 1, length.out = 3)
seq_t = seq(0, 1, length.out = 3)
knots = expand.grid(x = seq_x, y = seq_y, t = seq_t)
knots_sf = st_as_sf(knots, coords = c("x","y","t"), crs = NA, dim = "XYM", agr = "constant")

# Create a simple domain (of rectangles) to evaluate
shape1 = matrix(c(0.0,0.0, 0.5,0.0, 0.5,0.5, 0.0,0.5, 0.0,0.0), ncol=2, byrow=TRUE)
shape2 = shape1 + cbind(rep(0.5,5), rep(0.0,5))
shape3 = shape1 + cbind(rep(0.0,5), rep(0.5,5))
shape4 = shape1 + cbind(rep(0.5,5), rep(0.5,5))
sfc = st_sfc(
   st_polygon(list(shape1)),
   st_polygon(list(shape2)),
   st_polygon(list(shape3)),
   st_polygon(list(shape4))
)
dom = st_sf(data.frame(geoid = 1:length(sfc), geom = sfc))

rad = 0.5
period = c(0.4, 0.7)
areal_spacetime_bisquare(dom, period, knots, w = rad, w_t = 1)
areal_spacetime_bisquare(dom, period, knots_sf, w_s = rad, w_t = 1)

# Plot the (spatial) knots and the (spatial) domain at which we evaluated
# the basis.
plot(knots[,1], knots[,2], pch = 4, cex = 1.5, col = "red")
plot(dom[,1], col = NA, add = TRUE)

# Draw a circle representing the basis' radius around one of the knot points
tseq = seq(0, 2*pi, length=100) 
coords = cbind(rad * cos(tseq) + seq_x[2], rad * sin(tseq) + seq_y[2])
lines(coords, col = "red")

}
\seealso{
Other bisquare: 
\code{\link{areal_spatial_bisquare}()},
\code{\link{spacetime_bisquare}()},
\code{\link{spatial_bisquare}()}
}
\concept{bisquare}
